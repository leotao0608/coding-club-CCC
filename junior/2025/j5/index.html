<!--junior-2025-j5-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CCC '25 J5 - Connecting Territories</title>
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../../../style.css">
</head>

<body>
    <nav class="nav">
        <div class="nav-container">
            <h1 class="nav-logo">
                Junior Problem 5
            </h1>
        </div>
    </nav>
    
    <main class="container">
        <section class="content-section">
            <div>
                <button onclick="window.location.href='../../'" id="home-btn" class="nav-button">Back</button>
            </div>
            <section class="content-section">
                <div class="navigation-area">
                    <div>
                        <h1 style="text-align: center; font-size: 30px;">CCC '25 J5 - Connecting Territories</h1>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <a href="https://dmoj.ca/problem/ccc25j5" target="_blank" rel="noopener noreferrer" class="nav-button" style="text-decoration: none;">
                            View and submit this problem on DMOJ
                        </a>
                    </div>
                </div>
            </section>

            <section class="content-section" style="margin-top: 10px;">
                <h2>Problem Guide</h2>
                <div style="text-align: center;">
                    <button id="guide-btn" class="nav-button">Show Guide</button>
                </div>
                <div id="strategy-container" class="info-container" style="display: none;">
                    <pre class="info-text">
For this question, we will talk about finding an optimal path for Ava that starts at the upper territory
and ends at the lower territory but it doesn't really matter which direction you consider.
The first subtask gives us a clue on how to proceed. There are only two ways to reach the first or last 
tile in the second row, while there are three ways to reach each tile in between. Therefore we can quickly
calculate the minimum cost to get to each of the tiles in the second row. Our final answer will be the 
minimum of these C minimum costs.
That is where the clue lies, because once we determine the minimum cost to get to each tile in the second
row, we can ignore the first row, and consider the second and third rows as a repeat of the first subtask.

The general idea here is that we are solving the problem of determining the minimum cost to get to each
tile in a row by first solving the "subproblem" of determining the minimum cost to get to each tile in the 
previous row. These subproblems can be solved by using recursion. That is, most of the work can be done by 
a function called solve that calls itself containing a line similar to:
    return G[r][c] + min(solve(G,r-1,c-1),solve(G,r-1,c),solve(G,r-1,c+1))
where G[r][c] is the minimum cost to get to the tile in row r and column c. This approach will earn 11 marks
by solving the second subtask. It will be too slow to tackle grids with 100 rows and 100 columns because it
will often solve the same subproblem many times. (Can you see why?) One way to overcome this hurdle is to use
a technique called memoization which involves storing solutions to subproblems so they don't need to be be 
recalculated. Alternatively, you can use nested loops instead of recursion to walk through the grid from the
upper row to the lower row storing the "answer" at each tile you encounter. This works because you willalways
know the answer to each subproblem you need, when you need it.
These approaches are examples of what is called dynamic programming. They were described in a way that 
suggests the full grid be stored in memory and be used to solve solutions to subproblems. That will work for
the third subtask but will use up too much memory when the grid grows to 20000 rows and 20000 columns. This
can be avoided, and full marks earned, by realizing you only need to store "answers" for the previous and 
current rows.
                    </pre>
                </div>
            </section>

            <section class="content-section" style="margin-top: 10px;">
                <h2>Solution Code</h2>
                <div style="text-align: center;">
                    <button id="code-btn" class="nav-button">Show Code</button>
                </div>
                <div id="code-container" class="code-container" style="display: none;">
                    <pre id="code"><code class="language-cpp">
//score: 13/15
#include &lt;bits/stdc++.h&gt;
using namespace std;

int R, C, M;
vector&lt;vector&lt;int&gt;&gt; a, dp;

int dfs(int i, int j) {
    if (j &lt; 0 || j &gt;= C) return 1e9;  
    if (i == R-1) return a[i][j];          
    if (dp[i][j] != -1) return dp[i][j];   

    dp[i][j] = a[i][j] + min({dfs(i+1, j), dfs(i+1, j-1), dfs(i+1, j+1)});
    
    return dp[i][j];
}

int main() {
    cin &gt;&gt; R &gt;&gt; C &gt;&gt; M;
    a.resize(R, vector&lt;int&gt;(C));
    dp.assign(R, vector&lt;int&gt;(C, -1));

    int c = 1;
    for (int i=0; i&lt;R; i++) {
        for (int j=0; j&lt;C; j++) {
            a[i][j] = c;
            c++;
            if (c &gt; M) c = 1;
        }
    }

    int Min = 1e9;
    for (int j=0; j&lt;C; j++) {
        Min = min(Min, dfs(0, j));
    }
    cout &lt;&lt; Min;
    return 0;
}
                    </code></pre>
                </div>
            </section>
        </section>
    </main>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    
    <script src="../../problems.js"></script>
</body>
</html>